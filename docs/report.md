# 1. Введение

LZW (Lempel-Ziv-Welch) — это алгоритм сжатия данных без потерь,
который используется для сжатия текстовых файлов, изображений, звуковых
файлов и других типов данных. Он был разработан Абрахамом Лемпелем,
Якобом Зивом и Терри Уэлчем в 1984 году.

Если взглянуть почти на любой файл данных в компьютере, просматривая
символ за символом, то можно заметить множество повторяющихся элементов.
LZW — это метод сжатия данных, который воспользовался этим
повторением.

Алгоритм LZW использует словарь для сжатия данных. Он начинается с
заполненного словаря, содержащего все возможные односимвольные
последовательности (байты). Затем он читает входные данные и находит
наибольшую последовательность символов, которая уже есть в словаре. Он
отправляет индекс этой последовательности, а затем добавляет новую
последовательность символов в словарь и повторяет процесс.

## 1.1 Преимущества алгоритма

Преимущества алгоритма LZW:

1.  Хорошая степень сжатия: алгоритм обеспечивает хорошую степень сжатия для большинства типов данных. Это делает его очень полезным для хранения и передачи больших объемов данных, например, изображений, звуковых файлов и видео.

2.  Быстрая скорость сжатия и декомпрессии: LZW работает быстро, что делает его эффективным для использования на устройствах с ограниченными ресурсами, таких как мобильные телефоны.

3.  Простота реализации: алгоритм относительно прост в реализации, что делает его популярным для использования в различных приложениях.

## 1.2 Недостатки алгоритма

Недостатки алгоритма LZW:

1.  Требует большого словаря: LZW требует большого словаря, который может стать проблемой для устройств с ограниченной памятью.

2.  Проблемы с архивированием небольших файлов: для небольших файлов размер сжатых данных может быть больше, чем размер исходных данных.

3.  Затратный алгоритм: LZW может быть затратным в реализации, если его применять к большим объемам данных.

4.  Зависимость от начального словаря: эффективность сжатия алгоритма LZW зависит от начального словаря, поэтому в некоторых случаях, если словарь не оптимален, алгоритм может не давать наилучших результатов сжатия.

# 1.3 Применение алгоритма

Алгоритм LZW часто используется для сжатия данных в различных
приложениях, таких как сжатие текстовых файлов, аудио и видео файлов,
изображений и других данных, которые можно сжать путем замены
повторяющихся последовательностей на соответствующие коды.

Благодаря своей эффективности и простоте реализации, LZW остается одним
из наиболее популярных алгоритмов сжатия данных, используемых в
настоящее время.

# 2. Алгоритм сжатия

Алгоритм сжатия алгоритма LZW работает путем создания словаря символов,
ищет повторяющиеся последовательности символов, заменяет их на коды и
записывает их в выходной поток. В результате этого происходит сжатие
входных данных.

Описать алгоритм сжатия можно по шагам:

1.  Функция создает словарь, который содержит все возможные символы входных данных, каждый из которых представлен одним кодом.

2.  Функция читает входные данные, символ за символом, и записывает их в буфер.

3.  Функция начинает с чтения первого символа из буфера и добавляет его в текущую строку. Затем она начинает читать следующий символ и добавляет его в текущую строку, пока она не найдет такую последовательность символов, которой нет в словаре.

4.  Когда функция находит последовательность символов, которой нет в словаре, она добавляет эту последовательность в словарь и назначает ей новый код. Затем функция записывает код последней найденной последовательности символов в выходной поток.

5.  Функция повторяет шаги 3-4 для оставшихся символов в буфере.

6.  После обработки всех символов входных данных функция записывает оставшиеся коды символов в выходной поток.

7.  Функция возвращает выходной поток, который содержит сжатые данные в формате последовательности кодов символов.

## 2.1 Псевдокод алгоритма

    compress(input_string):
        dictionary = new map
        next_code = 256 // код следующей комбинации символов
        output_codes = []
        current_string = "" // инициализируем пустую текущую строку
        
        for char c in input_string:
            // создаем новую комбинацию символов
            new_string = current_string + c
            
            if new_string in dictionary: 
                current_string = new_string 
            else:
                // записываем код текущей комбинации в выходной вектор
                output_codes.append(dictionary[current_string]) 
                dictionary[new_string] = next_code
                next_code++
                current_string = c 
        
        output_codes.append(dictionary[current_string])
        
        return output_codes

## 2.2 Пример работы алгоритма

Пусть будет словарь,

| ИНДЕКС | ВХОД |
|--------|------|
| 1      | a    |
| 2      | b    |
| 3      | c    |
| 4      | d    |

и строка
> abdabccabсdab

, тогда шаги алгоритма будут

| ИНДЕКС          | ТЕКУЩАЯ СТРОКА | ВИДЕЛИ ЭТО РАНЬШЕ? | КОДИРОВАННЫЙ ВЫХОД        | НОВАЯ ЗАПИСЬ В СЛОВАРЕ/ИНДЕКС |
|-----------------|----------------|--------------------|---------------------------|-------------------------------|
| *а*             | *а*            | да                 | ничего                    | никакой                       |
| a*b*            | a*b*           | нет                | 0                         | ab / 4                        |
| ab*d*           | b*d*           | нет                | 0, 1                      | bd / 5                        |
| abd*а*          | d*а*           | нет                | 0, 1, 3                   | da / 6                        |
| abda*b*         | a*b*           | да                 | без изменений             | никакой                       |
| abdab*c*        | ab*c*          | нет                | 0, 1, 3, 4                | abc / 7                       |
| abdabc*c*       | c*c*           | нет                | 0, 1, 3, 4, 2             | cc / 8                        |
| abdabcc*a*      | c*a*           | нет                | 0, 1, 3, 4, 2, 2          | ca / 9                        |
| abdabcca*b*     | a*b*           | да                 | без изменений             | никакой                       |
| abdabccab*c*    | ab*c*          | да                 | без изменений             | никакой                       |
| abdabccabc*d*   | abc*d*         | нет                | 0, 1, 3, 4, 2, 2, 7       | abcd / 10                     |
| abdabccabcd*a*  | d*a*           | да                 | без изменений             | никакой                       |
| abdabccabcda*b* | da*b*          | нет                | 0, 1, 3, 4, 2, 2, 7, 6    | dab / 11                      |
| abdabccabсdab   | *b*            | да                 | 0, 1, 3, 4, 2, 2, 7, 6, 1 | никакой                       |

и получим выход
> 0, 1, 3, 4, 2, 2, 7, 6, 1

# 3. Алгоритм распаковки

Функция распаковки LZW работает в обратном порядке, чем функция сжатия. Она берет закодированные данные (например, коды) и восстанавливает исходные данные (например, символьную последовательность).

Описать алгоритм распаковки можно по шагам:

1. Распаковка начинается с инициализации таблицы символами алфавита. Это обычно означает, что первые 256 кодов таблицы уже заполнены символами ASCII.

2. Функция читает закодированные данные, начиная с первого кода.

3. Функция использует текущий код для извлечения соответствующей последовательности символов из таблицы. Если код уже присутствует в таблице, соответствующая последовательность символов извлекается непосредственно из таблицы. Если код не найден в таблице, распаковка создает новую последовательность символов, используя последний извлеченный символ и добавляет ее в таблицу.

4. После извлечения последовательности символов, функция добавляет ее в выходные данные.

5. После добавления последовательности символов в выходные данные, функция обновляет таблицу, добавляя новую последовательность символов в таблицу. Таким образом, эта новая последовательность становится доступной для извлечения на следующих итерациях распаковки.

6. Функция продолжает чтение входных данных и извлечение последовательностей символов до тех пор, пока не достигнут конец входных данных.

7. По завершении функции, выходные данные содержат исходную последовательность символов, а таблица содержит все последовательности, которые были использованы при сжатии.

## 3.1 Псевдокод алгоритма

    decompress(input_codes):
        dictionary = new HashTable
        next_code = 256
        output_string = ""
        previous_code = input_codes[0]
        output_string += dictionary[previous_code]
        
        for i from 1 to len(input_codes) - 1:
            current_code = input_codes[i] 
            
            if current_code in dictionary: 
                // текущей комбинацией становится комбинация из словаря
                current_string = dictionary[current_code]
            else:
                // создаем новую комбинацию из предыдущей и первого символа из нее
                current_string = dictionary[previous_code] + dictionary[previous_code][0]
            
            // добавляем комбинацию в выходную строку
            output_string += current_string

            // добавляем новую комбинацию и ее код в словарь
            dictionary[next_code] = dictionary[previous_code] + current_string[0]
            next_code++ 
            
            previous_code = current_code 
        
        return output_string 


## 3.2 Пример работы алгоритма

Пусть будет словарь

| ИНДЕКС | ВХОД |
|--------|------|
| 1      | a    |
| 2      | b    |
| 3      | c    |
| 4      | d    |

и коды
> 0, 1, 3, 4, 2, 2, 7, 6, 1

, тогда шаги алгоритма будут

| ИНДЕКС                      | ПРЕОБРАЗОВАНИЕ СЛОВАРЯ | ДЕКОДИРОВАННЫЙ ВЫХОД | ТЕКЩАЯ СТРОКА | НОВАЯ ЗАПИСЬ В СЛОВАРЕ/ИНДЕКС |
|-----------------------------|------------------------|----------------------|---------------|-------------------------------|
| *0*                         | 0 = *а*                | *а*                  | никакая       | никакая                       |
| 0, *1*                      | 1 = *b*                | a*b*                 | a             | ab / 4                        |
| 0, 1, *3*                   | 3 = *d*                | ab*d*                | b             | bd / 5                        |
| 0, 1, 3, *4*                | 4 = *ab*               | abd*ab*              | d             | da / 6                        |
| 0, 1, 3, 4, *2*             | 2 = *c*                | abdab*c*             | ab            | abc / 7                       |
| 0, 1, 3, 4, 2, *2*          | 2 = *c*                | abdabc*c*            | c             | cc / 8                        |
| 0, 1, 3, 4, 2, 2, *7*       | 7 = *abc*              | abdabcc*abc*         | c             | ca / 9                        |
| 0, 1, 3, 4, 2, 2, 7, *6*    | 6 = *da*               | abdabccabc*da*       | abc           | abcd / 10                     |
| 0, 1, 3, 4, 2, 2, 7, 6, *1* | 1 = *b*                | abdabccabcda*b*      | da            | dab / 11                      |

и получим выход
> abdabccabcdab

# 4. Оценка алгоритма

Обозначим длину входных данных как $n$, а размер алфавита $k$.

## 4.1 Оценка производительности

Время работы алгоритма LZW может быть оценено как $O(n \log k)$, где $\log k$ - это высота бинарного дерева, используемого для хранения словаря. Эта оценка производительности объясняется тем, что время работы алгоритма зависит от количества символов, которые нужно закодировать, и количества символов в алфавите. Кроме того, дополнительное время затрачивается на построение словаря и кодирование символов.

Получается, что если размер алфавита ограничен и меньше, чем логарифм от длины входных данных, то алгоритм LZW может быть считаться эффективным, так как его время работы будет линейным или близким к линейному. Однако, если размер алфавита очень большой, то время работы алгоритма может существенно увеличиться, что может привести к ухудшению производительности.

## 4.2 Оценка памяти

Оценка по памяти для алгоритма LZW может быть выражена как $O(n + k)$, где первый член означает, что необходимо хранить входные данные, а второй член означает, что необходимо хранить словарь, который может содержать до $k$ элементов, что может быть большим для больших алфавитов, но в общем случае оценка по памяти алгоритма LZW является линейной по размеру входных данных.

Алгоритм LZW обычно не требует большого объема памяти, и его оценка по памяти может быть приемлемой для большинства входных данных. Однако, при работе с очень большими алфавитами, объем памяти, необходимый для хранения словаря, может значительно возрастать, что может привести к ограничениям в работе алгоритма LZW.

# 5. Тестирующая система

Реализована система автоматических тестирований, которая включает себя:
1. Автоматическое тестирование на правильность.
2. Генератор тестов на производительность.
3. Автоматическое тестирование на производительность.

## 5.1 Формат входных данных

Первая строка: compress/decompress — сжать или распаковать. <br>
Остальные строки: если compress — текст, если decompress — коды.

## 5.2 Формат выходных данных

В зависимости от входных данных: compress — коды, decompress — текст.

## 5.3 Автоматичесткое тестирование на правильность

Работа системы по шагам:
1. Запускается цикл от 1 до $n$, где $n$ — количество тестов
2. Считывает файл с входными данными (.in)
3. Сравнивает работу алгоритма с файлом ответа (.ans)

## 5.4 Генератор тестов

Алгоритм генерации тестов заключается в том, что генерируется рандомная строка размером $n$, а дальше, в зависимости от выбора пользователя, выводим в файл либо сгенерированную строку, либо сжатую строку.

    string operation;
    cout << "compress/decompress: ";
    cin >> operation;
    if (operation != "compress" && operation != "decompress") {
        cout << "wrong input\n";
        return 0;
    }

    string path = "performanceTests/"+rand_str(8);
    ofstream output(path);
    output << operation << endl;

    int n;
    cout << "enter the length of the string: ";
    cin >> n;
    string rand_string = rand_str(n);

    if (operation == "compress") {
        output << rand_string << endl;
    } else {
        vector<int> compressed_data = compress(rand_string);

        for (auto i : compressed_data) {
            output << i << ' ';
        }
    }

## 5.5 Автоматичесткое тестирование на производительность

Работа системы по шагам:
1. Запускается цикл по всем файлам в папке с сгенерированными тестами
2. Считывает файл с входными данными
3. Замер времени работы алгоритма

# 6. Описание тестов на правильность
Ниже приведено описание тестов, используемые для автоматического тестирования итоговой реализации.

## Тесты 1-4
Проверка на корректность работы кодирования.
1. Пустой текст.
2. Маленький текст — i love bananas.
3. Несколько раз повторяющийся текст — say my name.
4. Монолог Гамлета "Быть или не быть".

## Тесты 5-8
Проверка на корректность работы декодирования.

5. Пустой текст.
6. Закодированный маленький текст — i love bananas.
7. Закодированный несколько раз повторяющийся текст — say my name.
8. Закодированный монолог Гамлета "Быть или не быть".

# Источники
* Семенюк В. В. Экономное кодирование дискретной информации. –СПб.: СПбГИТМО (ТУ), 2001. – 115 с. - Режим доступа: http://compression.ru/download/articles/rev_univ/semenyuk_2001_econom_encoding.pdf
* Mark R. Nelson «LZW Data Compression» [Электронный ресурс]: электрон. cтатья/ Mark R. Nelson, 1989. – Режим доступа: https://marknelson.us/posts/1989/10/01/lzw-data-compression.html
* Алгоритм LZW [Электронный ресурс]: электрон. cтатья/ информационный ресурс ИТМО, 2022. – Режим доступа: http://neerc.ifmo.ru/mediawiki/index.php?title=Алгоритм_LZW&redirect=no
* Hans Wennborg «Shrink, Reduce, and Implode: The Legacy Zip Compression Methods» [Электронный ресурс]: электрон. cтатья/ Hans Wennborg, 2021. – Режим доступа: https://www.hanshq.net/zip2.html
* «Подстановочные или словарно-ориентированные алгоритмы сжатия информации. Методы Лемпела-Зива» [Электронный ресурс]/ ИНТУИТ, 2007. Режим доступа: https://intuit.ru/studies/courses/2256/140/lecture/3904
* Michael Dipperstein «Lempel-Ziv-Welch (LZW) Encoding Discussion and Implementation» [Электронный ресурс]: электрон. cтатья/ Michael Dipperstein, 2015. Режим доступа: http://michael.dipperstein.com/lzw/
* Ziv J., Lempel A. «Compression of Individual Sequences via Variable-Rate Coding. » / IEEE Trans. Inform. Theory, 1978 – 530-536 с
* Welch T. «A Technique for High-Performance Data Compression. »/ Computer, 1984 – 8-19 с.
* Сэломон Д. «Сжатие данных, изображений и звука.» / М.Техносфера. 2006.
* Пантелеев Е. Р., Алыкова А. Л. «Алгоритмы сжатия данных без потерь»: учебное пособие для вузов / Е. Р. Пантелеев, А. Л. Алыкова. — СанктПетербург: Лань, 2021. – 172 с